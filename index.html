<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Quantum Gate Bird</title>
  <style>
    body { margin: 0; padding: 0; background: #000; color: #fff; font-family: sans-serif; text-align: center; }
    h1 { margin: 20px 0; }
    #gameCanvas { display: block; margin: 20px auto; border: 2px solid #444; background: #222; }
    #controls button { background: #6600cc; color: #fff; border: none; padding: 10px 15px; margin: 5px; font-size: 16px; cursor: pointer; }
    #controls button:hover { background: #9933ff; }
  </style>
</head>
<body>

<h1>Quantum Gate Bird 2.0</h1>
<canvas id="gameCanvas" width="600" height="600"></canvas>
<div id="controls">
  <button onclick="applyGate('X1')">X1</button>
  <button onclick="applyGate('X2')">X2</button>
  <button onclick="applyGate('Z1')">Z1</button>
  <button onclick="applyGate('Z2')">Z2</button>
  <button onclick="applyGate('H1')">H1</button>
  <button onclick="applyGate('H2')">H2</button>
  <button onclick="applyGate('CNOT12')">CNOT(1→2)</button>
  <button onclick="applyGate('CNOT21')">CNOT(2→1)</button>
  <button onclick="measure()">Measure</button>
  <button onclick="startGame()">Start/Reset</button>
</div>

<script>
let cv = document.getElementById("gameCanvas"), cx = cv.getContext("2d");
let state = [ [1,0],[0,0],[0,0],[0,0] ];
let pipes = [];
let score = 0;
let gameActive = false;
let spawnTimer = 0;
let spawnInterval = 100;
let pipeSpeed = 2;
let gates = {};

const X_2 = [ [[0,0],[1,0]], [[1,0],[0,0]] ];
const Z_2 = [ [[1,0],[0,0]], [[0,0],[-1,0]] ];
const H_2 = [ [[0.707,0],[0.707,0]], [[0.707,0],[-0.707,0]] ];
const I_2 = [ [[1,0],[0,0]], [[0,0],[1,0]] ];
const CNOT_12 = [
  [[1,0],[0,0],[0,0],[0,0]],
  [[0,0],[1,0],[0,0],[0,0]],
  [[0,0],[0,0],[0,0],[1,0]],
  [[0,0],[0,0],[1,0],[0,0]]
];
const CNOT_21 = [
  [[1,0],[0,0],[0,0],[0,0]],
  [[0,0],[0,0],[0,0],[1,0]],
  [[0,0],[0,0],[1,0],[0,0]],
  [[0,0],[1,0],[0,0],[0,0]]
];

function initGates() {
  gates.X1 = tensor4(X_2, I_2);
  gates.X2 = tensor4(I_2, X_2);
  gates.Z1 = tensor4(Z_2, I_2);
  gates.Z2 = tensor4(I_2, Z_2);
  gates.H1 = tensor4(H_2, I_2);
  gates.H2 = tensor4(I_2, H_2);
  gates.CNOT12 = CNOT_12;
  gates.CNOT21 = CNOT_21;
}
initGates();

function startGame() {
  state = [ [1,0],[0,0],[0,0],[0,0] ];
  normalizeState();
  pipes = [];
  score = 0;
  gameActive = true;
  spawnTimer = 0;
  pipeSpeed = 2;
  animate();
}

function animate() {
  if (!gameActive) return;
  spawnTimer++;
  if (spawnTimer > spawnInterval) {
    spawnTimer = 0;
    spawnPipe();
  }
  for (let p of pipes) p.x -= pipeSpeed;
  pipes = pipes.filter(p => p.x + 60 > 0);
  for (let p of pipes) {
    if (!p.scored && p.x + 60 < getBirdX() - 10) {
      p.scored = true;
      score++;
      if (score % 5 === 0) pipeSpeed += 0.5;
    }
  }
  checkCollision();
  draw();
  requestAnimationFrame(animate);
}

function spawnPipe() {
  let th = Math.floor(Math.random() * (cv.height - 150 - 40)) + 20;
  pipes.push({ x: cv.width, topH: th, gap: 150, scored: false });
}

function checkCollision() {
  let bx = getBirdX(), by = getBirdY();
  for (let p of pipes) {
    if (bx + 10 > p.x && bx - 10 < p.x + 60) {
      if (by - 10 < p.topH || by + 10 > p.topH + p.gap) {
        endGame();
      }
    }
  }
}

function endGame() {
  gameActive = false;
  cx.fillStyle = "rgba(0,0,0,0.5)";
  cx.fillRect(0, 0, cv.width, cv.height);
  cx.fillStyle = "#fff";
  cx.font = "30px Arial";
  cx.fillText("Game Over", cv.width/2 - 70, cv.height/2 - 20);
  cx.fillText("Score: " + score, cv.width/2 - 50, cv.height/2 + 20);
}

function draw() {
  cx.clearRect(0, 0, cv.width, cv.height);
  cx.fillStyle = "green";
  for (let p of pipes) {
    cx.fillRect(p.x, 0, 60, p.topH);
    cx.fillRect(p.x, p.topH + 150, 60, cv.height - (p.topH + 150));
  }
  cx.fillStyle = "yellow";
  cx.beginPath();
  cx.arc(getBirdX(), getBirdY(), 10, 0, 2 * Math.PI);
  cx.fill();
  cx.fillStyle = "white";
  cx.font = "20px Arial";
  cx.fillText("Score: " + score, 10, 25);
}

function getBirdX() {
  let p = magSq(state[2]) + magSq(state[3]);
  return p * (cv.width - 40) + 20;
}

function getBirdY() {
  let p = magSq(state[1]) + magSq(state[3]);
  return p * (cv.height - 40) + 20;
}

function applyGate(name) {
  let mat = gates[name];
  state = matVecMultiply(mat, state);
  normalizeState();
}

function measure() {
  let probs = state.map(a => magSq(a));
  let r = Math.random(), c = 0, idx = 0;
  for (let i = 0; i < 4; i++) {
    c += probs[i];
    if (r < c) { idx = i; break; }
  }
  let collapsed = [ [0,0],[0,0],[0,0],[0,0] ];
  collapsed[idx] = [1,0];
  state = collapsed;
}

function tensor4(A, B) {
  let res = new Array(4).fill(null).map(() => new Array(4).fill([0,0]));
  for (let rA=0; rA<2; rA++){
    for (let cA=0; cA<2; cA++){
      for (let rB=0; rB<2; rB++){
        for (let cB=0; cB<2; cB++){
          let prod = cm(A[rA][cA], B[rB][cB]);
          res[2*rA+rB][2*cA+cB] = ca(res[2*rA+rB][2*cA+cB], prod);
        }
      }
    }
  }
  return res;
}

function matVecMultiply(mat, vec) {
  let out = [ [0,0],[0,0],[0,0],[0,0] ];
  for (let i=0; i<4; i++){
    let sum = [0,0];
    for (let j=0; j<4; j++){
      sum = ca(sum, cm(mat[i][j], vec[j]));
    }
    out[i] = sum;
  }
  return out;
}

function normalizeState() {
  let s=0;
  for (let i=0;i<4;i++) s += magSq(state[i]);
  s = Math.sqrt(s);
  if (s<1e-12) { state=[ [1,0],[0,0],[0,0],[0,0] ]; return; }
  for (let i=0;i<4;i++){ state[i][0]/=s; state[i][1]/=s; }
}

function cm(a, b) {
  return [a[0]*b[0] - a[1]*b[1], a[0]*b[1] + a[1]*b[0]];
}

function ca(a, b) {
  return [a[0]+b[0], a[1]+b[1]];
}

function magSq(a) {
  return a[0]*a[0] + a[1]*a[1];
}
</script>
</body>
</html>
